Brute Force Approach
	# Query:
		* Simply iterate over the given range, maintaining a variable which updates if a lesser value is encountered.

		-> Pseudo Code:
			1. Iterate from left to right in the given range.

			2. Update min, if min>a[i].

	# Update:
		* Directly access the given index and update its value.

		-> Pseudo Code:
			1. Access given index (say i).

			2. set arr[i]=new_val.

Segment Tree
	# Pre-process/Build:
		* We tail recursively fill up/ build a binary tree s.t each of it's node represents
		a range of elements from array, and the node maintains the minimum value of this range

		-> Pseudo Code:
			1. If standing on a node that represents a single element of array, simply assign that element to this node's value and return;

			2. Else, recursively call build on left half and right half of the range representred by current node.

			3. Assign the minimum of the left and right child of the tree, as the value of current node and return.

	# Query:
		* We tail recursively find all the nodes which represent a sub-range of given range, and take the minimum of all such nodes' values.

		-> Pseudo Code:
			1. If standing on a node thet represents a single element, simply return the node's value.

			2. Else, if standing on a node which represents a subrange, that has no overlapping with the given range, return infinity(i.e a very large value out of scope of range of input).

			3. Else, recursively find the minimum of left and the right overlapping(wrt given range) ranges, and return it.

	# Update:
		* We tail recursively find the leaf node (i.e a node that represents a single element from array) which represents the given update index and update it, and all the nodes which represent a subrange, of which this index is a part of.

		-> Pseudo Code:
			1. If standing on a node thet represents a single element, simply upsate the node's value and return.

			2. Else, if standing on a node which represents a subrange that does not contain the given index, return.

			3. Else, recursively find the minimum of left child and the right child, and update the current node's value by their minimum and return.
